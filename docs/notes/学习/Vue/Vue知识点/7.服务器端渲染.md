---
title: 服务器端渲染
createTime: 2025/01/18 07:13:06
permalink: /learn/vue/Bj2B86Wid/
author: JackSim
tags:
  - vue
  - 服务器端渲染
  - SSR
  - CSR

description: description
---

SSR（Server-Side Rendering，服务端渲染）是指将页面内容在服务器端渲染后再发送给客户端的技术。

## SSR 的核心流程

1. **`服务器渲染`**：当用户访问网站时，服务器会请求 Vue 组件并渲染它们，将生成的 HTML 内容返回给浏览器。
2. **`客户端接管`**：浏览器接收到服务器渲染的 HTML 后，Vue 会在浏览器端“接管”页面，进行客户端的挂载和交互。这一步通常通过 Hydration 来完成，确保客户端和服务器端的内容一致。

Hydration 即：将服务器端渲染的静态 HTML 页面与客户端的 JavaScript 状态和行为进行“重新绑定”的过程。
```JavaScript
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

// Hydration：将服务器端渲染的 HTML 与 React 组件绑定
const initialState = window.__INITIAL_STATE__;  // 从服务器传递的初始状态
ReactDOM.hydrate(
  <App initialState={initialState} />,
  document.getElementById('root')   
);

```
- 在 React 中，这一过程是通过调用 ReactDOM.hydrate() 方法来实现的。
- 在 Vue.js 中，客户端应用使用 Vue.hydrate() 方法来处理页面元素和 Vue 实例之间的绑定。

**`Hydration 问题与挑战`**

- 性能：Hydration 的过程可能会增加客户端的加载时间，尤其是对于大型应用来说。过多的 JavaScript 代码可能导致延迟，影响首屏渲染时间。
- 不匹配问题：如果服务器渲染的 HTML 与客户端 React 组件的渲染不一致，Hydration 可能失败，导致页面闪烁或错误。通常是由于组件的状态不同步、环境差异或数据不一致等问题。
- 开发复杂性：Hydration 需要保证服务器和客户端的渲染一致，可能需要额外的配置和开发精细化管理，尤其是在复杂的应用场景下。



## 服务器端渲染条件

1. **`服务器`**: 需要一台运行支持 SSR 的服务器，可以是物理服务器、云服务器或虚拟主机。能够运行后端代码的运行时环境（如 Node.js、PHP、Python、Ruby 等）。
2. **`运行时环境`**: 
   - Node.js：如果使用现代 JavaScript 框架（如 Next.js 或 Nuxt.js）进行 SSR，需要安装 Node.js。
   - Python：如使用 Django + 模板引擎，需支持 Python 环境。
   - PHP：如使用 Laravel 或传统的 PHP 模板渲染。
   - Java：如使用 Spring Boot 或 JSP。

## Vue 3 的 SSR

Vue 3 提供了一些 API 来帮助实现服务端渲染。关键步骤如下

1. **`创建一个 Vue 服务器端应用`**
2. **`渲染 Vue 应用为 HTML`** 
3. **`处理客户端挂载`**

## 使用 Nuxt 3 实现 SSR

Nuxt 是 Vue 生态中专为 SSR 提供的框架，提供了开箱即用的 SSR 功能。Nuxt 会自动处理页面渲染、路由管理、静态资源优化等工作，开发者可以专注于业务逻辑。

### Nuxt SSR 的工作流程

1. **`请求处理`**   
   - 浏览器发起请求
   - 响应请求，Nuxt.js 的服务器（如基于 Node.js 的 Express 服务器）接收到请求后，将请求传递给 Nuxt 的处理流程
2. **`路由解析`**  
   - Nuxt 解析路由配置， 根据请求的 URL，Nuxt 查找与之匹配的页面组件。
   - 如果路由是动态的（如 /posts/:id），Nuxt 会根据 asyncData 或 fetch 方法加载相应的数据。

3. **`数据预取`**  
   - 如果页面组件中定义了 asyncData 方法或 fetch 方法，Nuxt 会在服务端调用这些方法。
   - 通过这些方法，页面可以预先获取数据（例如从数据库或 API 获取内容）。
   - asyncData 方法的返回值会与组件的 data 合并

4. **`服务端渲染 HTML`**
   - Nuxt 渲染组件树并生成对应的 HTML 字符串。
   - Nuxt 将生成的 HTML 插入到基础模板中（通常是 layouts/default.vue 或指定的布局文件）。
   - 模板中还会插入 Nuxt 的自动生成的 `<head>` 部分内容（如 SEO 元数据、CSS 链接等）。
   - 最终生成的 HTML 页面通过 HTTP 响应发送给客户端浏览器。

5. **`客户端激活`**
   - 浏览器接收服务端返回的 HTML 页面，并渲染到屏幕上。
   - 浏览器下载页面中嵌入的 JavaScript 文件。
   - Vue.js 的客户端代码在浏览器中“激活”页面，使得页面成为动态的。
   - 客户端和服务端的 Vue 实例会“复用”相同的虚拟 DOM，确保一致性。

6. **`后续用户交互`**
   - 一旦页面被激活，后续的页面导航（如点击链接）将由 Vue Router 和 Nuxt 的客户端代码处理。
   - 不再需要向服务器请求完整的 HTML 页面，而是通过异步加载数据更新页面内容（客户端渲染）。


## 手动配置 Webpack 或 Vite 实现 SSR

Vite 提供了插件 @vite/plugin-vue 来支持 Vue 3 项目的 SSR 设置。

## SSR 的性能优化

1. 缓存 HTML 内容
2. 对于一些不需要动态更新的页面，可以使用预渲染（Prerendering），预先在构建时生成 HTML 文件，避免每次都通过服务器渲染
3. 异步组件加载：在 SSR 中，尽量使用异步组件加载，这样可以按需加载组件，减少初始页面的 JavaScript 体积。
4. 懒加载路由：通过 Vue Router 的懒加载机制，按需加载路由和页面，减少初始页面加载的内容。
5. Tree-shaking 和代码分割：通过 Webpack 或 Vite 的代码分割和 tree-shaking，去除无用代码，减少 JavaScript 的体积，提高加载速度。
6. 减少客户端的 JavaScript 负担：虽然 SSR 已经提供了服务器端渲染的 HTML，但在客户端的“混合”过程中，Vue 会需要对 HTML 进行绑定。如果应用的 JavaScript 太大，混合过程可能会变慢。
7. SSR 与 CSR 的组合。 SSR 用于首屏加载，确保快速显示页面内容。CSR 用于后续导航和动态内容，避免每次用户交互都重新渲染页面，提高用户体验。

> [!NOTE]
> CSR 是指浏览器下载一个空的 HTML 页面（通常是一个包含了最基本结构的 HTML 文件），然后客户端的 JavaScript 代码接管页面渲染，动态地生成页面的内容。页面内容是通过 JavaScript 在浏览器中生成的，通常通过 Ajax 或 Fetch 请求从服务器获取数据



> [!NOTE]
> 使用Nuxt
> 1. 使用命令创建项目  
> ```Shell
> npx create-nuxt-app@latest my-nuxt3-app
> ```
> 2. 创建页面并进行服务器端渲染。 在 Nuxt 3 中，页面文件夹（pages/）中的 Vue 组件会自动变成路由，并支持 SSR。
> ```JavaScript
> <template>
>  <div>
>    <h1>Welcome to Nuxt 3 SSR Example</h1>
>    <p>The current time is: {{ serverTime }}</p>
>  </div>
> </template>
> 
> <script setup>
> //useAsyncData 是 Nuxt 3 的新 API，用于在服务器端获取数据，并自动在客户端缓存。
> const { data: serverTime } = await useAsyncData('server-time', () => {
>  return new Date().toLocaleString(); // 获取服务器时间
> });
> </script>
> ```
> 3.  运行 Nuxt 3 应用
> ```Shell
> npm run dev
> ```
> 4. 构建和部署 SSR 应用
> ```Shell
> npm run build  #先构建
> npm run start  #再启用，这将启动一个 Node.js 服务器，运行你的 Nuxt 3 SSR 应用
> ```
>
> 客户端代码也是在my-nuxt3-app下编写，并一同编译、构建