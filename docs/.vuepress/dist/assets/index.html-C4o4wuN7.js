import{_ as s,c as a,d as l,o as n}from"./app-C9wbIdcI.js";const e={};function t(h,i){return n(),a("div",null,i[0]||(i[0]=[l(`<p>SSR（Server-Side Rendering，服务端渲染）是指将页面内容在服务器端渲染后再发送给客户端的技术。</p><h2 id="ssr-的核心流程" tabindex="-1"><a class="header-anchor" href="#ssr-的核心流程"><span>SSR 的核心流程</span></a></h2><ol><li><strong><code>服务器渲染</code></strong>：当用户访问网站时，服务器会请求 Vue 组件并渲染它们，将生成的 HTML 内容返回给浏览器。</li><li><strong><code>客户端接管</code></strong>：浏览器接收到服务器渲染的 HTML 后，Vue 会在浏览器端“接管”页面，进行客户端的挂载和交互。这一步通常通过 Hydration 来完成，确保客户端和服务器端的内容一致。</li></ol><p>Hydration 即：将服务器端渲染的静态 HTML 页面与客户端的 JavaScript 状态和行为进行“重新绑定”的过程。</p><div class="language-javascript line-numbers-mode" data-ext="javascript" data-title="javascript"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">import</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> React</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">react</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">import</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> ReactDOM</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">react-dom</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">import</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> App</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">./App</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// Hydration：将服务器端渲染的 HTML 与 React 组件绑定</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> initialState</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> window</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">__INITIAL_STATE__</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 从服务器传递的初始状态</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">ReactDOM</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">hydrate</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  &lt;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">App</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> initialState</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">={</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">initialState</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> /&gt;,</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  document</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getElementById</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">root</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">   </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>在 React 中，这一过程是通过调用 ReactDOM.hydrate() 方法来实现的。</li><li>在 Vue.js 中，客户端应用使用 Vue.hydrate() 方法来处理页面元素和 Vue 实例之间的绑定。</li></ul><p><strong><code>Hydration 问题与挑战</code></strong></p><ul><li>性能：Hydration 的过程可能会增加客户端的加载时间，尤其是对于大型应用来说。过多的 JavaScript 代码可能导致延迟，影响首屏渲染时间。</li><li>不匹配问题：如果服务器渲染的 HTML 与客户端 React 组件的渲染不一致，Hydration 可能失败，导致页面闪烁或错误。通常是由于组件的状态不同步、环境差异或数据不一致等问题。</li><li>开发复杂性：Hydration 需要保证服务器和客户端的渲染一致，可能需要额外的配置和开发精细化管理，尤其是在复杂的应用场景下。</li></ul><h2 id="服务器端渲染条件" tabindex="-1"><a class="header-anchor" href="#服务器端渲染条件"><span>服务器端渲染条件</span></a></h2><ol><li><strong><code>服务器</code></strong>: 需要一台运行支持 SSR 的服务器，可以是物理服务器、云服务器或虚拟主机。能够运行后端代码的运行时环境（如 Node.js、PHP、Python、Ruby 等）。</li><li><strong><code>运行时环境</code></strong>: <ul><li>Node.js：如果使用现代 JavaScript 框架（如 Next.js 或 Nuxt.js）进行 SSR，需要安装 Node.js。</li><li>Python：如使用 Django + 模板引擎，需支持 Python 环境。</li><li>PHP：如使用 Laravel 或传统的 PHP 模板渲染。</li><li>Java：如使用 Spring Boot 或 JSP。</li></ul></li></ol><h2 id="vue-3-的-ssr" tabindex="-1"><a class="header-anchor" href="#vue-3-的-ssr"><span>Vue 3 的 SSR</span></a></h2><p>Vue 3 提供了一些 API 来帮助实现服务端渲染。关键步骤如下</p><ol><li><strong><code>创建一个 Vue 服务器端应用</code></strong></li><li><strong><code>渲染 Vue 应用为 HTML</code></strong></li><li><strong><code>处理客户端挂载</code></strong></li></ol><h2 id="使用-nuxt-3-实现-ssr" tabindex="-1"><a class="header-anchor" href="#使用-nuxt-3-实现-ssr"><span>使用 Nuxt 3 实现 SSR</span></a></h2><p>Nuxt 是 Vue 生态中专为 SSR 提供的框架，提供了开箱即用的 SSR 功能。Nuxt 会自动处理页面渲染、路由管理、静态资源优化等工作，开发者可以专注于业务逻辑。</p><h3 id="nuxt-ssr-的工作流程" tabindex="-1"><a class="header-anchor" href="#nuxt-ssr-的工作流程"><span>Nuxt SSR 的工作流程</span></a></h3><ol><li><p><strong><code>请求处理</code></strong></p><ul><li>浏览器发起请求</li><li>响应请求，Nuxt.js 的服务器（如基于 Node.js 的 Express 服务器）接收到请求后，将请求传递给 Nuxt 的处理流程</li></ul></li><li><p><strong><code>路由解析</code></strong></p><ul><li>Nuxt 解析路由配置， 根据请求的 URL，Nuxt 查找与之匹配的页面组件。</li><li>如果路由是动态的（如 /posts/:id），Nuxt 会根据 asyncData 或 fetch 方法加载相应的数据。</li></ul></li><li><p><strong><code>数据预取</code></strong></p><ul><li>如果页面组件中定义了 asyncData 方法或 fetch 方法，Nuxt 会在服务端调用这些方法。</li><li>通过这些方法，页面可以预先获取数据（例如从数据库或 API 获取内容）。</li><li>asyncData 方法的返回值会与组件的 data 合并</li></ul></li><li><p><strong><code>服务端渲染 HTML</code></strong></p><ul><li>Nuxt 渲染组件树并生成对应的 HTML 字符串。</li><li>Nuxt 将生成的 HTML 插入到基础模板中（通常是 layouts/default.vue 或指定的布局文件）。</li><li>模板中还会插入 Nuxt 的自动生成的 <code>&lt;head&gt;</code> 部分内容（如 SEO 元数据、CSS 链接等）。</li><li>最终生成的 HTML 页面通过 HTTP 响应发送给客户端浏览器。</li></ul></li><li><p><strong><code>客户端激活</code></strong></p><ul><li>浏览器接收服务端返回的 HTML 页面，并渲染到屏幕上。</li><li>浏览器下载页面中嵌入的 JavaScript 文件。</li><li>Vue.js 的客户端代码在浏览器中“激活”页面，使得页面成为动态的。</li><li>客户端和服务端的 Vue 实例会“复用”相同的虚拟 DOM，确保一致性。</li></ul></li><li><p><strong><code>后续用户交互</code></strong></p><ul><li>一旦页面被激活，后续的页面导航（如点击链接）将由 Vue Router 和 Nuxt 的客户端代码处理。</li><li>不再需要向服务器请求完整的 HTML 页面，而是通过异步加载数据更新页面内容（客户端渲染）。</li></ul></li></ol><h2 id="手动配置-webpack-或-vite-实现-ssr" tabindex="-1"><a class="header-anchor" href="#手动配置-webpack-或-vite-实现-ssr"><span>手动配置 Webpack 或 Vite 实现 SSR</span></a></h2><p>Vite 提供了插件 @vite/plugin-vue 来支持 Vue 3 项目的 SSR 设置。</p><h2 id="ssr-的性能优化" tabindex="-1"><a class="header-anchor" href="#ssr-的性能优化"><span>SSR 的性能优化</span></a></h2><ol><li>缓存 HTML 内容</li><li>对于一些不需要动态更新的页面，可以使用预渲染（Prerendering），预先在构建时生成 HTML 文件，避免每次都通过服务器渲染</li><li>异步组件加载：在 SSR 中，尽量使用异步组件加载，这样可以按需加载组件，减少初始页面的 JavaScript 体积。</li><li>懒加载路由：通过 Vue Router 的懒加载机制，按需加载路由和页面，减少初始页面加载的内容。</li><li>Tree-shaking 和代码分割：通过 Webpack 或 Vite 的代码分割和 tree-shaking，去除无用代码，减少 JavaScript 的体积，提高加载速度。</li><li>减少客户端的 JavaScript 负担：虽然 SSR 已经提供了服务器端渲染的 HTML，但在客户端的“混合”过程中，Vue 会需要对 HTML 进行绑定。如果应用的 JavaScript 太大，混合过程可能会变慢。</li><li>SSR 与 CSR 的组合。 SSR 用于首屏加载，确保快速显示页面内容。CSR 用于后续导航和动态内容，避免每次用户交互都重新渲染页面，提高用户体验。</li></ol><div class="hint-container note"><p class="hint-container-title">注</p><p>CSR 是指浏览器下载一个空的 HTML 页面（通常是一个包含了最基本结构的 HTML 文件），然后客户端的 JavaScript 代码接管页面渲染，动态地生成页面的内容。页面内容是通过 JavaScript 在浏览器中生成的，通常通过 Ajax 或 Fetch 请求从服务器获取数据</p></div><div class="hint-container note"><p class="hint-container-title">注</p><p>使用Nuxt</p><ol><li>使用命令创建项目</li></ol><div class="language-shell line-numbers-mode" data-ext="shell" data-title="shell"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">npx</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> create-nuxt-app@latest</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> my-nuxt3-app</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="2"><li>创建页面并进行服务器端渲染。 在 Nuxt 3 中，页面文件夹（pages/）中的 Vue 组件会自动变成路由，并支持 SSR。</li></ol><div class="language-javascript line-numbers-mode" data-ext="javascript" data-title="javascript"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">template</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">div</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">   &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">h1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Welcome to Nuxt 3 SSR Example</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">h1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">   &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">The current time is: {{ serverTime }}</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">div</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">template</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">script</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> setup</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">//useAsyncData 是 Nuxt 3 的新 API，用于在服务器端获取数据，并自动在客户端缓存。</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">const </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> data</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">: </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">serverTime</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> = await useAsyncData(&#39;server-time&#39;, () =&gt; </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> return</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Date</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">().</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toLocaleString</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">; </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 获取服务器时间</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">script</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>运行 Nuxt 3 应用</li></ol><div class="language-shell line-numbers-mode" data-ext="shell" data-title="shell"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">npm</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> dev</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="4"><li>构建和部署 SSR 应用</li></ol><div class="language-shell line-numbers-mode" data-ext="shell" data-title="shell"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">npm</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> build</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  #先构建</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">npm</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> start</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  #再启用，这将启动一个 Node.js 服务器，运行你的 Nuxt 3 SSR 应用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端代码也是在my-nuxt3-app下编写，并一同编译、构建</p></div>`,23)]))}const k=s(e,[["render",t],["__file","index.html.vue"]]),r=JSON.parse('{"path":"/learn/vue/Bj2B86Wid/","title":"服务器端渲染","lang":"zh-CN","frontmatter":{"title":"服务器端渲染","createTime":"2025/01/18 07:13:06","permalink":"/learn/vue/Bj2B86Wid/","author":"JackSim","tags":["vue","服务器端渲染","SSR","CSR"],"description":"description"},"headers":[],"readingTime":{"minutes":6.03,"words":1810},"git":{"updatedTime":1737195346000,"contributors":[{"name":"meishenlieshou","username":"meishenlieshou","email":"meishenlieshou@gmail.com","commits":1,"avatar":"https://avatars.githubusercontent.com/meishenlieshou?v=4","url":"https://github.com/meishenlieshou"}]},"filePathRelative":"notes/学习/Vue/Vue知识点/7.服务器端渲染.md","bulletin":false}');export{k as comp,r as data};
